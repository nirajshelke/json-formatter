The `lightning/ariaObserver` module provides an easy way for users to write accessible component that works in both synthetic and native shadow.

## Aria ID referencing in native shadow
Use the` AriaObserver` library to write accessible component that works where `ariaLabelledBy` would break native shadow. 

Here's an example that won't work with native shadow. In the following code, we support attribute `ariaLabelledBy` in our component `c-foo`, so the `input` element is labelled by external elements.

``` html
<template>
    <input aria-labelledby={ariaLabelledBy}>
</template>
```

```
class Foo extends LightningElement {
    @api ariaLabelledBy;
}
```

This example uses the `aria-labelledby` attribute to use the internal input as an external label in `c-foo`.

``` html
<span id="my-label">Input field</span>
<c-foo aria-labelledby="my-label"></c-foo>
```

The above example works fine in synthetic shadow, but in native shadow mode, the `aria-labelledby` ID reference is broken. The `input` element is isolated in its own shadow DOM, so the label with id `my-label` isn't in the same shadow boundary.

## Creating AriaObserver

To use `AriaObserver` in your component, first import it from `lightning/ariaObserver`. Then, instantiate the `AriaObserver` within your component.

The `AriaObserver` constructor takes one parameter:
- `cmpReference` The reference of the current component (`this`).

``` js
import AriaObserver from 'lightning/ariaObserver';

class Foo extends LightningElement {
    constructor() {
        super();
        this.ariaObserver = new AriaObserver(this);
    }
}
```

Next, use the `connect(options)` method to connect between the internal element and the external reference. It takes an options object with the following keys:
- `targetSelector` The selector to the internal element where the aria attribute should be attached.
- `attribute` The name of the aria attribute. Two supported options: `aria-labelledby`and `aria-describedby`.
- `id` The ID of the external element. Alternatively, you can use `ids` for multiple IDs.

This example uses `connect(options)` to display an aria label for the internal `input` element.
``` js
@api
get ariaLabelledBy() {
    return this._ariaLabelledBy;
}
set ariaLabelledBy(refs) {
    this._ariaLabelledBy = refs;

    this.ariaObserver.connect({
        targetSelector: 'input',
        attribute: 'aria-labelledby',
        id: refs
    });
}
```

Then use the `sync()` method to synchronize the ID references when the template is re-rendered.

``` js
renderedCallback() {
    this.ariaObserver.sync();
}
```

Finally, disconnect the aria observer and free the resources at the end of the component lifecycle.

``` js
disconnectedCallback() {
    if (this.ariaObserver) {
        this.ariaObserver.disconnect();
        this.ariaObserver = undefined;
    }
}
```

Here is all these steps combined into a complete example of a component using `AriaObserver`.

``` html
<template>
    <!-- element where the aria attribute is attached -->
    <input>
</template>
```

``` js
import {api, LightningElement} from 'lwc';
import AriaObserver from 'lightning/ariaObserver';

export default class Foo extends LightningElement {
    constructor() {
        super();
        this.ariaObserver = new AriaObserver(this);
    }

    _ariaLabelledBy = '';

    @api
    get ariaLabelledBy() {
        return this._ariaLabelledBy;
    }
    set ariaLabelledBy(refs) {
        this._ariaLabelledBy = refs;

        /* Establish the connection between input and the external label */
        this.ariaObserver.connect({
            targetSelector: 'input',
            attribute: 'aria-labelledby',
            id: refs
        });
    }

    renderedCallback() {
        this.ariaObserver.sync();
    }

    disconnectedCallback() {
        if (this.ariaObserver) {
            this.ariaObserver.disconnect();
            this.ariaObserver = undefined;
        }
    }
}
```

## Limitations
`AriaObserver` only works with text-only aria ID references.

Supported attributes:
- `aria-labelledby`
- `aria-describedby`
