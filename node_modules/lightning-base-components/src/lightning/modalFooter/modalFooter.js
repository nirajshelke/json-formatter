import { LightningElement } from 'lwc';
import { classSet } from 'lightning/utils';
import { findAllTabbableElements, filterTooltips } from 'lightning/focusUtils';

// SLDS Modal Footer classes
const footerClass = 'slds-modal__footer';
const hideClass = 'slds-hide';
// selectors
const footerSelector = `.${footerClass}`;
const footerSlotSelector = '[data-footer-slot]';
// timeout footer height check
// checking quickly yields faster resolution of correct
// footer (not a typo) placement
const SIZE_CHECK_TIMER = 50;
// limited to 4 quick checks totalling 200 ms, which catches
// any misreported heights based on reflow of content in modalFooter
const MAX_HEIGHT_CHECKS = 4;

/**
 * The modal footer component to display footer content in lightning modal.
 * */
export default class LightningModalFooter extends LightningElement {
    // tracked private state
    initialRender = true;
    initialSlotRender = true;
    hideFooter = false;
    unregisterCallback = null;
    footerHeightTracked = 0;
    footerHeightChecked = 0;
    timeoutId = 0;

    /**
     * Handle the default slot change event
     * Always register with parent every slot change
     * @private
     */
    handleDefaultSlotChange() {
        // Set this once so that parent can know slot
        // has rendered
        if (this.initialSlotRender) {
            this.initialSlotRender = false;
        }
        this.registerWithParent();
        this.hideFooter = !this.isDefaultSlotPopulated;
    }

    /**
     * Gets the CSS classes applicable to the modal footer element.
     * Hidden classes are set when the footer is hidden
     * @returns {string} CSS class applied to modal footer
     * @private
     */
    get footerCssClasses() {
        const classes = classSet(footerClass);
        classes.add({
            [hideClass]: this.hideFooter,
        });
        return classes.toString();
    }

    /**
     * Get the height of outer wrapper of modal footer
     * @returns {number} represents a height value in pixels
     * @private
     */
    get footerHeight() {
        const divElem = this.template.querySelector(footerSelector);
        const footerRect = divElem ? divElem.getBoundingClientRect() : {};
        const { height } = footerRect;
        const heightValue = height || 0;
        this.footerHeightTracked = heightValue;
        return heightValue;
    }

    /**
     * Get an element reference to the modal footer's slot element
     * @returns {(HTMLElement|null)}
     * @private
     */
    get defaultSlotElement() {
        return this.template.querySelector(footerSlotSelector);
    }

    /**
     * Determine whether the default slot is populated
     * @returns {boolean}
     * @private
     */
    get isDefaultSlotPopulated() {
        const slotElement = this.defaultSlotElement;
        if (slotElement && slotElement.assignedNodes) {
            return slotElement.assignedNodes().length > 0;
        }
        return true;
    }

    /**
     * Get first tabbable element within modalFooter's slot, if exists
     * This is passed to parent in order to possibly be used for autoFocus
     * @returns {(HTMLElement|null)}
     * @private
     */
    get firstTabbableElement() {
        let firstElem = null;
        if (this.isDefaultSlotPopulated) {
            const filteredElements = filterTooltips(
                findAllTabbableElements(this.defaultSlotElement)
            );
            if (filteredElements.length > 0) {
                firstElem = filteredElements[0];
            }
        }
        return firstElem;
    }

    /**
     * if not the intial render, check for footer height chnage,
     * when a window resize occurs
     * @returns {Object}
     * @private
     */
    handleModalFooterResizeCheck() {
        // when not intial render, and footer height changed
        // return the tracked value, otherwise indicate no change
        return !this.initialRender && this.hasFooterHeightChanged()
            ? { changed: true, value: this.footerHeightTracked }
            : { changed: false, value: null };
    }

    /**
     * Register modalFooter with modal parent, including callbacks to
     * unregister the modal footer
     * this will get called multiple times over component lifecycle
     * @type {CustomEvent}
     * @private
     */
    registerWithParent() {
        const evtRegister = new CustomEvent('privatemodalfooterregister', {
            bubbles: true,
            composed: true,
            detail: {
                footerHeight: this.footerHeight,
                defaultSlotIsPopulated: this.isDefaultSlotPopulated,
                defaultSlotHasRendered: !this.initialSlotRender,
                firstTabbableElemRef: this.firstTabbableElement,
                checkFooterHeightCallback:
                    this.handleModalFooterResizeCheck.bind(this),
                unRegisterCallback: (unregisterCallback) => {
                    this.unregisterCallback = unregisterCallback;
                },
            },
        });
        this.dispatchEvent(evtRegister);
    }

    /**
     * Provide a means to check whether the tracked footer height
     * is different than the current footer height to only call modalBase
     * when there is a change in footer height
     * @private
     */
    hasFooterHeightChanged() {
        // note: calling this.footerHeight updates this.footerHeightTracked
        // order of values checked here is required
        const previousRenderedHeight = this.footerHeightTracked;
        const currentRenderedHeight = this.footerHeight;
        return currentRenderedHeight !== previousRenderedHeight;
    }

    /**
     * On first render, provide a quick means of updating modalBase,
     * if the modalFooter height changes.
     * In rare cases, the height of the footer between the
     * normal or full size rendering can change depending on
     * content of footer and window width
     * @private
     */
    scheduleFooterHeightCheck() {
        if (this.initialRender && this.timeoutId === 0) {
            // eslint-disable-next-line @lwc/lwc/no-async-operation
            this.timeoutId = setInterval(() => {
                if (this.footerHeightChecked >= MAX_HEIGHT_CHECKS) {
                    clearTimeout(this.timeoutId);
                    this.timeoutId = 0;
                    this.footerHeightChecked = 0;
                } else {
                    this.footerHeightChecked++;
                    if (this.hasFooterHeightChanged()) {
                        this.registerWithParent();
                    }
                }
            }, SIZE_CHECK_TIMER);
        }
    }

    /**
     * When modal footer is being created, initialize
     * private tracked modal footer state
     * This is need because modal footer can be added back to
     * the DOM, after being removed, and need to re-initialize state values
     * @private
     */
    initState() {
        this.initialRender = true;
        this.initialSlotRender = true;
        this.hideFooter = false;
        this.unregisterCallback = null;
        this.footerHeightTracked = 0;
        this.footerHeightChecked = 0;
        this.timeoutId = 0;
    }

    connectedCallback() {
        // handle case where modalFooter is added/removed/added to DOM
        // so registerWithParent gets called
        this.initState();
    }

    disconnectedCallback() {
        if (this.unregisterCallback) {
            this.unregisterCallback();
        }
        clearTimeout(this.timeoutId);
        this.timeoutId = 0;
        this.footerHeightChecked = 0;
    }

    renderedCallback() {
        if (this.initialRender) {
            this.registerWithParent();
            this.scheduleFooterHeightCheck();
            this.initialRender = false;
        }
        this.hideFooter = !this.isDefaultSlotPopulated;
    }
}
